{"version":3,"sources":["../lib/v4/index.ts","../lib/v4/isZodErrorLike.ts","../lib/v4/ValidationError.ts","../lib/v4/isValidationError.ts","../lib/v4/isValidationErrorLike.ts","../lib/v4/errorMap/custom.ts","../lib/v4/errorMap/invalidElement.ts","../lib/v4/errorMap/invalidKey.ts","../lib/utils/prependWithAOrAn.ts","../lib/utils/stringify.ts","../lib/v4/errorMap/invalidStringFormat.ts","../lib/utils/isPrimitive.ts","../lib/v4/errorMap/invalidType.ts","../lib/v4/errorMap/invalidUnion.ts","../lib/utils/joinValues.ts","../lib/v4/errorMap/invalidValue.ts","../lib/v4/errorMap/notMultipleOf.ts","../lib/v4/errorMap/tooBig.ts","../lib/v4/errorMap/tooSmall.ts","../lib/v4/errorMap/unrecognizedKeys.ts","../lib/v4/errorMap/errorMap.ts","../lib/utils/NonEmptyArray.ts","../lib/utils/joinPath.ts","../lib/utils/titleCase.ts","../lib/v4/MessageBuilder.ts","../lib/v4/fromZodError.ts","../lib/v4/toValidationError.ts","../lib/v4/fromError.ts","../lib/v4/fromZodIssue.ts"],"sourcesContent":["export { ValidationError, type ErrorOptions } from './ValidationError.ts';\nexport { isValidationError } from './isValidationError.ts';\nexport { isValidationErrorLike } from './isValidationErrorLike.ts';\nexport { isZodErrorLike } from './isZodErrorLike.ts';\nexport { createErrorMap, type ErrorMapOptions } from './errorMap/index.ts';\nexport { fromError } from './fromError.ts';\nexport { fromZodIssue, type FromZodIssueOptions } from './fromZodIssue.ts';\nexport {\n  fromZodError,\n  type FromZodErrorOptions,\n  type ZodError,\n} from './fromZodError.ts';\nexport { toValidationError } from './toValidationError.ts';\nexport {\n  type MessageBuilder,\n  type ZodIssue,\n  createMessageBuilder,\n  type MessageBuilderOptions,\n} from './MessageBuilder.ts';\nexport { type NonEmptyArray } from '../utils/NonEmptyArray.ts';\n","import type * as zod from 'zod/v4/core';\n\nexport function isZodErrorLike(err: unknown): err is zod.$ZodError {\n  return (\n    err instanceof Object &&\n    'name' in err &&\n    (err.name === 'ZodError' || err.name === '$ZodError') &&\n    'issues' in err &&\n    Array.isArray(err.issues)\n  );\n}\n","import { isZodErrorLike } from './isZodErrorLike.ts';\nimport type * as zod from 'zod/v4/core';\n\nexport const ZOD_VALIDATION_ERROR_NAME = 'ZodValidationError';\n\n// make zod-validation-error compatible with\n// earlier to es2022 typescript configurations\n// @see https://github.com/causaly/zod-validation-error/issues/226\nexport interface ErrorOptions {\n  cause?: unknown;\n}\n\nexport class ValidationError extends Error {\n  name: typeof ZOD_VALIDATION_ERROR_NAME;\n  details: Array<zod.$ZodIssue>;\n\n  constructor(message?: string, options?: ErrorOptions) {\n    super(message, options);\n    this.name = ZOD_VALIDATION_ERROR_NAME;\n    this.details = getIssuesFromErrorOptions(options);\n  }\n\n  toString(): string {\n    return this.message;\n  }\n}\n\nfunction getIssuesFromErrorOptions(\n  options?: ErrorOptions\n): Array<zod.$ZodIssue> {\n  if (options) {\n    const cause = options.cause;\n    if (isZodErrorLike(cause)) {\n      return cause.issues;\n    }\n  }\n\n  return [];\n}\n","import { ValidationError } from './ValidationError.ts';\n\nexport function isValidationError(err: unknown): err is ValidationError {\n  return err instanceof ValidationError;\n}\n","import {\n  ZOD_VALIDATION_ERROR_NAME,\n  type ValidationError,\n} from './ValidationError.ts';\n\nexport function isValidationErrorLike(err: unknown): err is ValidationError {\n  return err instanceof Error && err.name === ZOD_VALIDATION_ERROR_NAME;\n}\n","import type * as zod from 'zod/v4/core';\nimport type { AbstractSyntaxTree } from './types.ts';\n\nexport function parseCustomIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueCustom>\n): AbstractSyntaxTree {\n  return {\n    type: issue.code,\n    path: issue.path,\n    message: issue.message ?? 'Invalid input',\n  };\n}\n","import type * as zod from 'zod/v4/core';\nimport type { AbstractSyntaxTree } from './types.ts';\n\nexport function parseInvalidElementIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueInvalidElement>\n): AbstractSyntaxTree {\n  return {\n    type: issue.code,\n    path: issue.path,\n    message: `unexpected element in ${issue.origin}`,\n  };\n}\n","import type * as zod from 'zod/v4/core';\nimport type { AbstractSyntaxTree } from './types.ts';\n\nexport function parseInvalidKeyIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueInvalidKey>\n): AbstractSyntaxTree {\n  return {\n    type: issue.code,\n    path: issue.path,\n    message: `unexpected key in ${issue.origin}`,\n  };\n}\n","const vowelSoundCharSet = new Set(['a', 'e', 'i', 'o', 'u', 'h']);\n\nexport function prependWithAOrAn(value: string): string {\n  const firstLetter = value.charAt(0).toLowerCase();\n  const prefix = vowelSoundCharSet.has(firstLetter) ? 'an' : 'a';\n  return [prefix, value].join(' ');\n}\n","import type { util } from 'zod/v4/core';\n\nexport function stringifySymbol(symbol: symbol): string {\n  return symbol.description ?? '';\n}\n\nexport type StringifyValueOptions = {\n  wrapStringValueInQuote?: boolean;\n  localization?: boolean | Intl.LocalesArgument;\n};\n\nexport function stringify(\n  value: util.Primitive | Date,\n  options: StringifyValueOptions = {}\n): string {\n  switch (typeof value) {\n    case 'symbol':\n      return stringifySymbol(value);\n    case 'bigint':\n    case 'number': {\n      switch (options.localization) {\n        case true:\n          return value.toLocaleString();\n        case false:\n          return value.toString();\n        default:\n          return value.toLocaleString(options.localization);\n      }\n    }\n    case 'string': {\n      if (options.wrapStringValueInQuote) {\n        return `\"${value}\"`;\n      }\n      return value;\n    }\n    default: {\n      if (value instanceof Date) {\n        switch (options.localization) {\n          case true:\n            return value.toLocaleString();\n          case false:\n            return value.toISOString();\n          default:\n            return value.toLocaleString(options.localization);\n        }\n      }\n      return String(value);\n    }\n  }\n}\n","import { prependWithAOrAn } from '../../utils/prependWithAOrAn.ts';\nimport { stringify } from '../../utils/stringify.ts';\nimport type * as zod from 'zod/v4/core';\nimport type { AbstractSyntaxTree, ErrorMapOptions } from './types.ts';\n\nexport function parseInvalidStringFormatIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueInvalidStringFormat>,\n  options: Pick<\n    ErrorMapOptions,\n    'displayInvalidFormatDetails' | 'reportInput' | 'numberLocalization'\n  >\n): AbstractSyntaxTree {\n  let message = '';\n\n  switch (issue.format) {\n    case 'lowercase':\n    case 'uppercase':\n      message += `expected ${issue.format} string`;\n      break;\n    case 'starts_with': {\n      message += `expected string to start with \"${issue.prefix}\"`;\n      break;\n    }\n    case 'ends_with': {\n      message += `expected string to end with \"${issue.suffix}\"`;\n      break;\n    }\n    case 'includes': {\n      message += `expected string to include \"${issue.includes}\"`;\n      break;\n    }\n    case 'regex': {\n      message += 'expected string to match pattern';\n      if (options.displayInvalidFormatDetails) {\n        message += ` \"${issue.pattern}\"`;\n      }\n      break;\n    }\n    case 'jwt': {\n      message += 'expected a jwt';\n      if (\n        options.displayInvalidFormatDetails &&\n        issue.inst &&\n        'alg' in issue.inst._zod.def\n      ) {\n        message += `/${issue.inst._zod.def.alg}`;\n      }\n      message += ' token';\n      break;\n    }\n    case 'email': {\n      message += 'expected an email address';\n      break;\n    }\n    case 'url':\n    case 'uuid':\n    case 'guid':\n    case 'cuid':\n    case 'cuid2':\n    case 'ulid':\n    case 'xid':\n    case 'ksuid': {\n      message += `expected a ${issue.format.toUpperCase()}`;\n      if (issue.inst && 'version' in issue.inst._zod.def) {\n        message += ` ${issue.inst._zod.def.version}`;\n      }\n      break;\n    }\n    case 'date':\n    case 'datetime':\n    case 'time':\n    case 'duration': {\n      message += `expected an ISO ${issue.format}`;\n      break;\n    }\n    case 'ipv4':\n    case 'ipv6': {\n      message += `expected an ${issue.format\n        .slice(0, 2)\n        .toUpperCase()}${issue.format.slice(2)} address`;\n      break;\n    }\n    case 'cidrv4':\n    case 'cidrv6': {\n      message += `expected a ${issue.format\n        .slice(0, 4)\n        .toUpperCase()}${issue.format.slice(4)} address range`;\n      break;\n    }\n    case 'base64':\n    case 'base64url': {\n      message += `expected a ${issue.format} encoded string`;\n      break;\n    }\n    case 'e164': {\n      message += 'expected an E.164 formatted phone number';\n      break;\n    }\n    default: {\n      if (issue.format.startsWith('sha') || issue.format.startsWith('md5')) {\n        const [alg, encoding] = issue.format.split('_');\n        message += `expected a ${alg.toUpperCase()}`;\n        if (encoding) {\n          message += ` ${encoding}-encoded`;\n        }\n        message += ` hash`;\n        break;\n      }\n\n      message += `expected ${prependWithAOrAn(issue.format)}`;\n    }\n  }\n\n  if ('input' in issue && options.reportInput === 'typeAndValue') {\n    const valueStr = stringify(issue.input, {\n      wrapStringValueInQuote: true,\n      localization: options.numberLocalization,\n    });\n    message += `, received ${valueStr}`;\n  }\n\n  return {\n    type: issue.code,\n    path: issue.path,\n    message,\n  };\n}\n","import type { util } from 'zod/v4/core';\n\nexport function isPrimitive(value: unknown): value is util.Primitive {\n  if (value === null) {\n    return true;\n  }\n\n  switch (typeof value) {\n    case 'string':\n    case 'number':\n    case 'bigint':\n    case 'boolean':\n    case 'symbol':\n    case 'undefined':\n      return true;\n    default:\n      return false;\n  }\n}\n","import { isPrimitive } from '../../utils/isPrimitive.ts';\nimport { stringify } from '../../utils/stringify.ts';\nimport type { AbstractSyntaxTree, ErrorMapOptions } from './types.ts';\nimport type * as zod from 'zod/v4/core';\n\nexport function parseInvalidTypeIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueInvalidType>,\n  options: Pick<\n    ErrorMapOptions,\n    'reportInput' | 'numberLocalization' | 'dateLocalization'\n  >\n): AbstractSyntaxTree {\n  let message = `expected ${issue.expected}`;\n\n  // note: it's possible that issue.input is not defined\n  if ('input' in issue && options.reportInput !== false) {\n    const value = issue.input;\n    message += `, received ${getTypeName(value)}`;\n\n    if (options.reportInput === 'typeAndValue') {\n      if (isPrimitive(value)) {\n        const valueStr = stringify(value, {\n          wrapStringValueInQuote: true,\n          localization: options.numberLocalization,\n        });\n        message += ` (${valueStr})`;\n      } else if (value instanceof Date) {\n        const valueStr = stringify(value, {\n          localization: options.dateLocalization,\n        });\n        message += ` (${valueStr})`;\n      }\n    }\n  }\n\n  return {\n    type: issue.code,\n    path: issue.path,\n    message,\n  };\n}\n\nexport function getTypeName(value: unknown): string {\n  if (typeof value === 'object') {\n    if (value === null) {\n      return 'null';\n    }\n    if (value === undefined) {\n      return 'undefined';\n    }\n    if (Array.isArray(value)) {\n      return 'array';\n    }\n    if (value instanceof Date) {\n      return 'date';\n    }\n    if (value instanceof RegExp) {\n      return 'regexp';\n    }\n    if (value instanceof Map) {\n      return 'map';\n    }\n    if (value instanceof Set) {\n      return 'set';\n    }\n    if (value instanceof Error) {\n      return 'error';\n    }\n    if (value instanceof Function) {\n      return 'function';\n    }\n    return 'object';\n  }\n\n  return typeof value;\n}\n","import type * as zod from 'zod/v4/core';\nimport type { AbstractSyntaxTree } from './types.ts';\n\nexport function parseInvalidUnionIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueInvalidUnion>\n): AbstractSyntaxTree {\n  return {\n    type: issue.code,\n    path: issue.path,\n    message: issue.message ?? 'Invalid input',\n  };\n}\n","import { stringify } from './stringify.ts';\nimport type { util } from 'zod/v4/core';\n\nexport type JoinValuesOptions = {\n  separator: string;\n  lastSeparator?: string;\n  wrapStringValuesInQuote?: boolean;\n  maxValuesToDisplay?: number;\n};\n\nexport function joinValues(\n  values: Array<util.Primitive>,\n  options: JoinValuesOptions\n): string {\n  const valuesToDisplay = (\n    options.maxValuesToDisplay\n      ? values.slice(0, options.maxValuesToDisplay)\n      : values\n  ).map((value) => {\n    return stringify(value, {\n      wrapStringValueInQuote: options.wrapStringValuesInQuote,\n    });\n  });\n\n  // add remaining values count (if any)\n  // this is to avoid displaying too many values in the error message\n  // and to keep the message concise\n  // e.g. `\"foo\", \"bar\", \"baz\" or 3 more value(s)`\n  if (valuesToDisplay.length < values.length) {\n    valuesToDisplay.push(\n      `${values.length - valuesToDisplay.length} more value(s)`\n    );\n  }\n\n  return valuesToDisplay.reduce<string>((acc, value, index) => {\n    if (index > 0) {\n      if (index === valuesToDisplay.length - 1 && options.lastSeparator) {\n        acc += options.lastSeparator;\n      } else {\n        acc += options.separator;\n      }\n    }\n\n    acc += value;\n\n    return acc;\n  }, '');\n}\n","import { isPrimitive } from '../../utils/isPrimitive.ts';\nimport { joinValues } from '../../utils/joinValues.ts';\nimport { stringify } from '../../utils/stringify.ts';\nimport type { AbstractSyntaxTree, ErrorMapOptions } from './types.ts';\nimport type * as zod from 'zod/v4/core';\n\nexport function parseInvalidValueIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueInvalidValue>,\n  options: Pick<\n    ErrorMapOptions,\n    | 'allowedValuesSeparator'\n    | 'maxAllowedValuesToDisplay'\n    | 'wrapAllowedValuesInQuote'\n    | 'allowedValuesLastSeparator'\n    | 'reportInput'\n    | 'numberLocalization'\n    | 'dateLocalization'\n  >\n): AbstractSyntaxTree {\n  let message: string;\n\n  if (issue.expected === 'stringbool') {\n    message = 'expected boolean as string';\n  } else if (issue.values.length === 0) {\n    message = 'invalid value';\n  } else if (issue.values.length === 1) {\n    const valueStr = stringify(issue.values[0], {\n      wrapStringValueInQuote: true,\n    });\n    message = `expected value to be ${valueStr}`;\n  } else {\n    const valuesStr = joinValues(issue.values, {\n      separator: options.allowedValuesSeparator,\n      lastSeparator: options.allowedValuesLastSeparator,\n      wrapStringValuesInQuote: options.wrapAllowedValuesInQuote,\n      maxValuesToDisplay: options.maxAllowedValuesToDisplay,\n    });\n    message = `expected value to be one of ${valuesStr}`;\n  }\n\n  if ('input' in issue && options.reportInput === 'typeAndValue') {\n    if (isPrimitive(issue.input)) {\n      const valueStr = stringify(issue.input, {\n        wrapStringValueInQuote: true,\n        localization: options.numberLocalization,\n      });\n      message += `, received ${valueStr}`;\n    } else if (issue.input instanceof Date) {\n      const valueStr = stringify(issue.input, {\n        localization: options.dateLocalization,\n      });\n      message += `, received ${valueStr}`;\n    }\n  }\n\n  return {\n    type: issue.code,\n    path: issue.path,\n    message,\n  };\n}\n","import { stringify } from '../../utils/stringify.ts';\nimport type * as zod from 'zod/v4/core';\nimport type { AbstractSyntaxTree, ErrorMapOptions } from './types.ts';\n\nexport function parseNotMultipleOfIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueNotMultipleOf>,\n  options: Pick<ErrorMapOptions, 'reportInput' | 'numberLocalization'>\n): AbstractSyntaxTree {\n  let message = `expected multiple of ${issue.divisor}`;\n\n  if ('input' in issue && options.reportInput === 'typeAndValue') {\n    const valueStr = stringify(issue.input, {\n      wrapStringValueInQuote: true,\n      localization: options.numberLocalization,\n    });\n    message += `, received ${valueStr}`;\n  }\n\n  return {\n    type: issue.code,\n    path: issue.path,\n    message,\n  };\n}\n","import { isPrimitive } from '../../utils/isPrimitive.ts';\nimport { stringify } from '../../utils/stringify.ts';\nimport type { AbstractSyntaxTree, ErrorMapOptions } from './types.ts';\nimport type * as zod from 'zod/v4/core';\n\nexport function parseTooBigIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueTooBig>,\n  options: Pick<\n    ErrorMapOptions,\n    'dateLocalization' | 'numberLocalization' | 'reportInput'\n  >\n): AbstractSyntaxTree {\n  const maxValueStr =\n    issue.origin === 'date'\n      ? stringify(new Date(issue.maximum as number), {\n          localization: options.dateLocalization,\n        })\n      : stringify(issue.maximum, {\n          localization: options.numberLocalization,\n        });\n\n  let message = '';\n\n  switch (issue.origin) {\n    case 'number':\n    case 'int':\n    case 'bigint': {\n      message += `expected number to be less than${\n        issue.inclusive ? ' or equal to' : ''\n      } ${maxValueStr}`;\n      break;\n    }\n    case 'string': {\n      message += `expected string to contain at most ${maxValueStr} character(s)`;\n      break;\n    }\n    case 'date': {\n      message += `expected date to be prior ${\n        issue.inclusive ? 'or equal to' : 'to'\n      } \"${maxValueStr}\"`;\n      break;\n    }\n    case 'array': {\n      message += `expected array to contain at most ${maxValueStr} item(s)`;\n      break;\n    }\n    case 'set': {\n      message += `expected set to contain at most ${maxValueStr} item(s)`;\n      break;\n    }\n    case 'file': {\n      message += `expected file to not exceed ${maxValueStr} byte(s) in size`;\n      break;\n    }\n    default: {\n      message += `expected value to be less than${\n        issue.inclusive ? ' or equal to' : ''\n      } ${maxValueStr}`;\n    }\n  }\n\n  if ('input' in issue && options.reportInput === 'typeAndValue') {\n    const value = issue.input;\n\n    if (isPrimitive(value)) {\n      const valueStr = stringify(value, {\n        wrapStringValueInQuote: true,\n        localization: options.numberLocalization,\n      });\n      message += `, received ${valueStr}`;\n    } else if (value instanceof Date) {\n      const valueStr = stringify(value, {\n        localization: options.dateLocalization,\n      });\n      message += `, received ${valueStr}`;\n    }\n  }\n\n  return {\n    type: issue.code,\n    path: issue.path,\n    message,\n  };\n}\n","import { stringify } from '../../utils/stringify.ts';\nimport { isPrimitive } from '../../utils/isPrimitive.ts';\nimport type * as zod from 'zod/v4/core';\nimport type { AbstractSyntaxTree, ErrorMapOptions } from './types.ts';\n\nexport function parseTooSmallIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueTooSmall>,\n  options: Pick<\n    ErrorMapOptions,\n    'dateLocalization' | 'numberLocalization' | 'reportInput'\n  >\n): AbstractSyntaxTree {\n  const minValueStr =\n    issue.origin === 'date'\n      ? stringify(new Date(issue.minimum as number), {\n          localization: options.dateLocalization,\n        })\n      : stringify(issue.minimum, {\n          localization: options.numberLocalization,\n        });\n  let message = '';\n\n  switch (issue.origin) {\n    case 'number':\n    case 'int':\n    case 'bigint': {\n      message += `expected number to be greater than${\n        issue.inclusive ? ' or equal to' : ''\n      } ${minValueStr}`;\n      break;\n    }\n    case 'date': {\n      message += `expected date to be ${\n        issue.inclusive ? 'later or equal to' : 'later to'\n      } \"${minValueStr}\"`;\n      break;\n    }\n    case 'string': {\n      message += `expected string to contain at least ${minValueStr} character(s)`;\n      break;\n    }\n    case 'array': {\n      message += `expected array to contain at least ${minValueStr} item(s)`;\n      break;\n    }\n    case 'set': {\n      message += `expected set to contain at least ${minValueStr} item(s)`;\n      break;\n    }\n    case 'file': {\n      message += `expected file to be at least ${minValueStr} byte(s) in size`;\n      break;\n    }\n    default:\n      message += `expected value to be greater than${\n        issue.inclusive ? ' or equal to' : ''\n      } ${minValueStr}`;\n  }\n\n  if ('input' in issue && options.reportInput === 'typeAndValue') {\n    const value = issue.input;\n\n    if (isPrimitive(value)) {\n      const valueStr = stringify(value, {\n        wrapStringValueInQuote: true,\n        localization: options.numberLocalization,\n      });\n      message += `, received ${valueStr}`;\n    } else if (value instanceof Date) {\n      const valueStr = stringify(value, {\n        localization: options.dateLocalization,\n      });\n      message += `, received ${valueStr}`;\n    }\n  }\n\n  return {\n    type: issue.code,\n    path: issue.path,\n    message,\n  };\n}\n","import { joinValues } from '../../utils/joinValues.ts';\nimport type * as zod from 'zod/v4/core';\nimport type { AbstractSyntaxTree, ErrorMapOptions } from './types.ts';\n\nexport function parseUnrecognizedKeysIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueUnrecognizedKeys>,\n  options: Pick<\n    ErrorMapOptions,\n    | 'unrecognizedKeysSeparator'\n    | 'unrecognizedKeysLastSeparator'\n    | 'wrapUnrecognizedKeysInQuote'\n    | 'maxUnrecognizedKeysToDisplay'\n  >\n): AbstractSyntaxTree {\n  const keysStr = joinValues(issue.keys, {\n    separator: options.unrecognizedKeysSeparator,\n    lastSeparator: options.unrecognizedKeysLastSeparator,\n    wrapStringValuesInQuote: options.wrapUnrecognizedKeysInQuote,\n    maxValuesToDisplay: options.maxUnrecognizedKeysToDisplay,\n  });\n\n  return {\n    type: issue.code,\n    path: issue.path,\n    message: `unrecognized key(s) ${keysStr} in object`,\n  };\n}\n","import { parseCustomIssue } from './custom.ts';\nimport { parseInvalidElementIssue } from './invalidElement.ts';\nimport { parseInvalidKeyIssue } from './invalidKey.ts';\nimport { parseInvalidStringFormatIssue } from './invalidStringFormat.ts';\nimport { parseInvalidTypeIssue } from './invalidType.ts';\nimport { parseInvalidUnionIssue } from './invalidUnion.ts';\nimport { parseInvalidValueIssue } from './invalidValue.ts';\nimport { parseNotMultipleOfIssue } from './notMultipleOf.ts';\nimport { parseTooBigIssue } from './tooBig.ts';\nimport { parseTooSmallIssue } from './tooSmall.ts';\nimport { parseUnrecognizedKeysIssue } from './unrecognizedKeys.ts';\nimport type {\n  AbstractSyntaxTree,\n  ErrorMapOptions,\n  IssueType,\n} from './types.ts';\nimport type * as zod from 'zod/v4/core';\n\ntype IssueParsers = {\n  [IssueCode in IssueType]: (\n    issue: zod.$ZodRawIssue<Extract<zod.$ZodIssue, { code: IssueCode }>>,\n    options: ErrorMapOptions\n  ) => AbstractSyntaxTree;\n};\n\nconst issueParsers: IssueParsers = {\n  invalid_type: parseInvalidTypeIssue,\n  too_big: parseTooBigIssue,\n  too_small: parseTooSmallIssue,\n  invalid_format: parseInvalidStringFormatIssue,\n  invalid_value: parseInvalidValueIssue,\n  invalid_element: parseInvalidElementIssue,\n  not_multiple_of: parseNotMultipleOfIssue,\n  unrecognized_keys: parseUnrecognizedKeysIssue,\n  invalid_key: parseInvalidKeyIssue,\n  custom: parseCustomIssue,\n  invalid_union: parseInvalidUnionIssue,\n};\n\nexport const defaultErrorMapOptions = {\n  reportInput: 'type',\n  displayInvalidFormatDetails: false,\n  allowedValuesSeparator: ', ',\n  allowedValuesLastSeparator: ' or ',\n  wrapAllowedValuesInQuote: true,\n  maxAllowedValuesToDisplay: 10,\n  unrecognizedKeysSeparator: ', ',\n  unrecognizedKeysLastSeparator: ' and ',\n  wrapUnrecognizedKeysInQuote: true,\n  maxUnrecognizedKeysToDisplay: 5,\n  dateLocalization: true,\n  numberLocalization: true,\n} as const satisfies ErrorMapOptions;\n\nexport function createErrorMap(\n  partialOptions: Partial<ErrorMapOptions> = {}\n): zod.$ZodErrorMap<zod.$ZodIssue> {\n  // fill-in default options\n  const options = {\n    ...defaultErrorMapOptions,\n    ...partialOptions,\n  };\n\n  const errorMap: zod.$ZodErrorMap<zod.$ZodIssue> = (issue) => {\n    if (issue.code === undefined) {\n      // TODO: handle this case\n      return 'Not supported issue type';\n    }\n\n    const parseFunc = issueParsers[issue.code] as (\n      iss: typeof issue,\n      opts: ErrorMapOptions\n    ) => AbstractSyntaxTree;\n    const ast = parseFunc(issue, options);\n    return ast.message;\n  };\n\n  return errorMap;\n}\n","export type NonEmptyArray<T> = [T, ...T[]];\n\nexport function isNonEmptyArray<T>(value: T[]): value is NonEmptyArray<T> {\n  return value.length !== 0;\n}\n","import { stringifySymbol } from './stringify.ts';\nimport type { NonEmptyArray } from './NonEmptyArray.ts';\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers\n */\nconst identifierRegex = /[$_\\p{ID_Start}][$\\u200c\\u200d\\p{ID_Continue}]*/u;\n\nexport function joinPath(path: NonEmptyArray<PropertyKey>): string {\n  if (path.length === 1) {\n    let propertyKey = path[0];\n\n    if (typeof propertyKey === 'symbol') {\n      propertyKey = stringifySymbol(propertyKey);\n    }\n\n    return propertyKey.toString() || '\"\"';\n  }\n\n  return path.reduce<string>((acc, propertyKey) => {\n    // handle numeric indices\n    if (typeof propertyKey === 'number') {\n      return acc + '[' + propertyKey.toString() + ']';\n    }\n\n    // handle symbols\n    if (typeof propertyKey === 'symbol') {\n      propertyKey = stringifySymbol(propertyKey);\n    }\n\n    // handle quoted values\n    if (propertyKey.includes('\"')) {\n      return acc + '[\"' + escapeQuotes(propertyKey) + '\"]';\n    }\n\n    // handle special characters\n    if (!identifierRegex.test(propertyKey)) {\n      return acc + '[\"' + propertyKey + '\"]';\n    }\n\n    // handle normal values\n    const separator = acc.length === 0 ? '' : '.';\n    return acc + separator + propertyKey;\n  }, '');\n}\n\nfunction escapeQuotes(str: string): string {\n  return str.replace(/\"/g, '\\\\\"');\n}\n","export function titleCase(value: string): string {\n  if (value.length === 0) {\n    return value;\n  }\n  return value.charAt(0).toUpperCase() + value.slice(1);\n}\n","import { joinPath } from '../utils/joinPath.ts';\nimport { isNonEmptyArray, type NonEmptyArray } from '../utils/NonEmptyArray.ts';\nimport { titleCase } from '../utils/titleCase.ts';\nimport type * as zod from 'zod/v4/core';\n\nexport type ZodIssue = zod.$ZodIssue;\n\nexport type MessageBuilder = (issues: NonEmptyArray<ZodIssue>) => string;\n\nexport type MessageBuilderOptions = {\n  prefix: string | null | undefined;\n  prefixSeparator: string;\n  maxIssuesInMessage: number;\n  issueSeparator: string;\n  unionSeparator: string;\n  includePath: boolean;\n  forceTitleCase: boolean;\n};\n\nexport const defaultMessageBuilderOptions: MessageBuilderOptions & {\n  prefix: string;\n} = {\n  prefix: 'Validation error',\n  prefixSeparator: ': ',\n  maxIssuesInMessage: 99, // I've got 99 problems but the b$tch ain't one\n  unionSeparator: ' or ',\n  issueSeparator: '; ',\n  includePath: true,\n  forceTitleCase: true,\n};\n\nexport function createMessageBuilder(\n  partialOptions: Partial<MessageBuilderOptions> = {}\n): MessageBuilder {\n  const options = {\n    ...defaultMessageBuilderOptions,\n    ...partialOptions,\n  };\n\n  return function messageBuilder(issues) {\n    const message = issues\n      // limit max number of issues printed in the reason section\n      .slice(0, options.maxIssuesInMessage)\n      // format error message\n      .map((issue) => mapIssue(issue, options))\n      // concat as string\n      .join(options.issueSeparator);\n\n    return conditionallyPrefixMessage(message, options);\n  };\n}\n\nfunction mapIssue(\n  issue: zod.$ZodIssue,\n  options: MessageBuilderOptions\n): string {\n  if (issue.code === 'invalid_union' && isNonEmptyArray(issue.errors)) {\n    const individualMessages = issue.errors.map((issues) =>\n      issues\n        .map((subIssue) =>\n          mapIssue(\n            {\n              ...subIssue,\n              path: issue.path.concat(subIssue.path),\n            },\n            options\n          )\n        )\n        .join(options.issueSeparator)\n    );\n\n    // deduplicate messages\n    // and join them with the union separator\n    // to create a single message for the invalid union issue\n    return Array.from(new Set(individualMessages)).join(options.unionSeparator);\n  }\n\n  const buf = [];\n\n  if (options.forceTitleCase) {\n    buf.push(titleCase(issue.message));\n  } else {\n    buf.push(issue.message);\n  }\n\n  pathCondition: if (\n    options.includePath &&\n    issue.path !== undefined &&\n    isNonEmptyArray(issue.path)\n  ) {\n    // handle array indices\n    if (issue.path.length === 1) {\n      const identifier = issue.path[0];\n\n      if (typeof identifier === 'number') {\n        buf.push(` at index ${identifier}`);\n        break pathCondition;\n      }\n    }\n\n    buf.push(` at \"${joinPath(issue.path)}\"`);\n  }\n\n  return buf.join('');\n}\n\nfunction conditionallyPrefixMessage(\n  message: string,\n  options: Pick<MessageBuilderOptions, 'prefix' | 'prefixSeparator'>\n): string {\n  if (options.prefix != null) {\n    if (message.length > 0) {\n      return [options.prefix, message].join(options.prefixSeparator);\n    }\n\n    return options.prefix;\n  }\n\n  if (message.length > 0) {\n    return message;\n  }\n\n  // if both reason and prefix are empty, return default prefix\n  // to avoid having an empty error message\n  return defaultMessageBuilderOptions.prefix;\n}\n","import { isNonEmptyArray } from '../utils/NonEmptyArray.ts';\nimport { fromError } from './fromError.ts';\nimport { isZodErrorLike } from './isZodErrorLike.ts';\nimport {\n  createMessageBuilder,\n  type MessageBuilderOptions,\n  type MessageBuilder,\n} from './MessageBuilder.ts';\nimport { ValidationError } from './ValidationError.ts';\nimport type * as zod from 'zod/v4/core';\n\nexport type ZodError = zod.$ZodError;\n\nexport type FromZodErrorOptions =\n  | {\n      messageBuilder: MessageBuilder;\n    }\n  // maintain backwards compatibility\n  | Partial<MessageBuilderOptions>;\n\nexport function fromZodError(\n  zodError: ZodError,\n  options: FromZodErrorOptions = {}\n): ValidationError {\n  // perform runtime check to ensure the input is a ZodError\n  // why? because people have been historically using this function incorrectly\n  if (!isZodErrorLike(zodError)) {\n    throw new TypeError(\n      `Invalid zodError param; expected instance of ZodError. Did you mean to use the \"${fromError.name}\" method instead?`\n    );\n  }\n\n  return fromZodErrorWithoutRuntimeCheck(zodError, options);\n}\n\nexport function fromZodErrorWithoutRuntimeCheck(\n  zodError: ZodError,\n  options: FromZodErrorOptions = {}\n): ValidationError {\n  const zodIssues = zodError.issues;\n\n  let message: string;\n  if (isNonEmptyArray(zodIssues)) {\n    const messageBuilder = createMessageBuilderFromOptions(options);\n    message = messageBuilder(zodIssues);\n  } else {\n    message = zodError.message;\n  }\n\n  return new ValidationError(message, { cause: zodError });\n}\n\nfunction createMessageBuilderFromOptions(\n  options: FromZodErrorOptions\n): MessageBuilder {\n  if ('messageBuilder' in options) {\n    return options.messageBuilder;\n  }\n\n  return createMessageBuilder(options);\n}\n","import { ValidationError } from './ValidationError.ts';\nimport { isZodErrorLike } from './isZodErrorLike.ts';\nimport {\n  fromZodErrorWithoutRuntimeCheck,\n  type FromZodErrorOptions,\n} from './fromZodError.ts';\n\nexport const toValidationError =\n  (options: FromZodErrorOptions = {}) =>\n  (err: unknown): ValidationError => {\n    if (isZodErrorLike(err)) {\n      return fromZodErrorWithoutRuntimeCheck(err, options);\n    }\n\n    if (err instanceof Error) {\n      return new ValidationError(err.message, { cause: err });\n    }\n\n    return new ValidationError('Unknown error');\n  };\n","import { toValidationError } from './toValidationError.ts';\nimport type { FromZodErrorOptions } from './fromZodError.ts';\nimport type { ValidationError } from './ValidationError.ts';\n\n/**\n * This function is a non-curried version of `toValidationError`\n */\nexport function fromError(\n  err: unknown,\n  options: FromZodErrorOptions = {}\n): ValidationError {\n  return toValidationError(options)(err);\n}\n","import * as zod from 'zod/v4/core';\n\nimport {\n  type MessageBuilder,\n  type MessageBuilderOptions,\n  type ZodIssue,\n  createMessageBuilder,\n} from './MessageBuilder.ts';\nimport { ValidationError } from './ValidationError.ts';\n\nexport type FromZodIssueOptions =\n  | {\n      messageBuilder: MessageBuilder;\n    }\n  // maintain backwards compatibility\n  | Partial<Omit<MessageBuilderOptions, 'maxIssuesInMessage'>>;\n\nexport function fromZodIssue(\n  issue: ZodIssue,\n  options: FromZodIssueOptions = {}\n): ValidationError {\n  const messageBuilder = createMessageBuilderFromOptions(options);\n  const message = messageBuilder([issue]);\n\n  return new ValidationError(message, {\n    cause: new zod.$ZodRealError([issue]),\n  });\n}\n\nfunction createMessageBuilderFromOptions(\n  options: FromZodIssueOptions\n): MessageBuilder {\n  if ('messageBuilder' in options) {\n    return options.messageBuilder;\n  }\n\n  return createMessageBuilder(options);\n}\n"],"mappings":"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","names":["createMessageBuilderFromOptions"]}