{"file_contents":{"CliqSyncAI/server.js":{"content":"const express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst config = require('./config/env');\nrequire('./config/database');\n\nconst app = express();\nrequire('dotenv').config();\nconsole.log(\"Loaded BACKEND_API_KEY:\", process.env.BACKEND_API_KEY);\n\n// API Key Middleware\napp.use((req, res, next) => {\n  const key = req.headers['x-api-key'];\n\n  if (!key || key !== process.env.BACKEND_API_KEY) {\n    return res.status(403).json({\n      error: \"Unauthorized - Invalid API Key\"\n    });\n  }\n\n  next();\n});\n\n\napp.use(cors());\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/api/health', (req, res) => {\n  res.json({\n    status: 'OK',\n    service: 'CliqSync AI Backend',\n    timestamp: new Date().toISOString()\n  });\n});\n\nconst authRoutes = require('./routes/auth');\nconst trelloRoutes = require('./routes/trello');\nconst webhookRoutes = require('./routes/webhooks');\nconst aiRoutes = require('./routes/ai');\nconst eventRoutes = require('./routes/events');\n\napp.use('/auth', authRoutes);\napp.use('/api/trello', trelloRoutes);\napp.use('/webhooks', webhookRoutes);\napp.use('/api/ai', aiRoutes);\napp.use('/api/events', eventRoutes);\n\napp.use((req, res) => {\n  res.status(404).json({ error: 'Endpoint not found' });\n});\n\napp.use((err, req, res, next) => {\n  console.error('Server error:', err);\n  res.status(500).json({ error: 'Internal server error', message: err.message });\n});\n\nconst PORT = config.port;\napp.listen(PORT, '0.0.0.0', () => {\n  console.log(`CliqSync AI Backend running on port ${PORT}`);\n  console.log(`Health check: http://localhost:${PORT}/api/health`);\n});\n","path":null,"size_bytes":1663,"size_tokens":null},"CliqSyncAI/controllers/webhookController.js":{"content":"const TrelloEvent = require('../models/TrelloEvent');\n\nexports.handleTrelloWebhook = (req, res) => {\n  if (req.method === 'HEAD') {\n    return res.status(200).end();\n  }\n\n  try {\n    const webhookData = req.body;\n\n    if (!webhookData.action) {\n      return res.status(200).json({ received: true });\n    }\n\n    const action = webhookData.action;\n    const actionType = action.type;\n\n    let eventData = {\n      eventType: actionType,\n      cardId: null,\n      cardName: null,\n      listId: null,\n      listName: null,\n      boardId: null,\n      boardName: null,\n      payload: webhookData\n    };\n\n    if (action.data?.card) {\n      eventData.cardId = action.data.card.id;\n      eventData.cardName = action.data.card.name;\n    }\n\n    if (action.data?.list) {\n      eventData.listId = action.data.list.id;\n      eventData.listName = action.data.list.name;\n    }\n\n    if (action.data?.board) {\n      eventData.boardId = action.data.board.id;\n      eventData.boardName = action.data.board.name;\n    }\n\n    if (actionType.includes('card')) {\n      TrelloEvent.create(eventData);\n      console.log(`Trello event recorded: ${actionType} - ${eventData.cardName || 'Unknown'}`);\n    }\n\n    res.status(200).json({ received: true });\n  } catch (error) {\n    console.error('Webhook error:', error);\n    res.status(500).json({ error: error.message });\n  }\n};\n\nexports.getRecentEvents = (req, res) => {\n  try {\n    const limit = parseInt(req.query.limit) || 20;\n    const events = TrelloEvent.getRecent(limit);\n    res.json({ success: true, data: events });\n  } catch (error) {\n    res.status(500).json({ success: false, error: error.message });\n  }\n};\n","path":null,"size_bytes":1639,"size_tokens":null},"CliqSyncAI/config/database.js":{"content":"const Database = require('better-sqlite3');\nconst path = require('path');\n\nconst dbPath = process.env.DB_PATH || path.join(__dirname, '..', 'database.sqlite');\nconst db = new Database(dbPath);\n\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS users (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    userId TEXT UNIQUE NOT NULL,\n    trelloAccessToken TEXT,\n    trelloRefreshToken TEXT,\n    expiresAt INTEGER,\n    createdAt INTEGER DEFAULT (strftime('%s', 'now')),\n    updatedAt INTEGER DEFAULT (strftime('%s', 'now'))\n  )\n`);\n\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS trello_events (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    eventType TEXT NOT NULL,\n    cardId TEXT,\n    cardName TEXT,\n    listId TEXT,\n    listName TEXT,\n    boardId TEXT,\n    boardName TEXT,\n    payload TEXT,\n    createdAt INTEGER DEFAULT (strftime('%s', 'now'))\n  )\n`);\n\nmodule.exports = db;\n","path":null,"size_bytes":852,"size_tokens":null},"CliqSyncAI/controllers/authController.js":{"content":"const crypto = require('crypto');\nconst User = require('../models/User');\nconst config = require('../config/env');\n\nconst authSessions = new Map();\nconst SESSION_TIMEOUT = 10 * 60 * 1000;\n\nsetInterval(() => {\n  const now = Date.now();\n  for (const [state, data] of authSessions.entries()) {\n    if (now - data.timestamp > SESSION_TIMEOUT) {\n      authSessions.delete(state);\n    }\n  }\n}, 60 * 1000);\n\nexports.startTrelloAuth = (req, res) => {\n  const userId = req.query.userId;\n  \n  if (!userId) {\n    return res.status(400).json({ \n      success: false, \n      error: 'userId parameter is required' \n    });\n  }\n\n  const state = crypto.randomBytes(32).toString('hex');\n  authSessions.set(state, { userId, timestamp: Date.now() });\n\n  const redirectUri = `${config.trello.redirectUri}?state=${state}`;\n  const authUrl = `https://trello.com/1/authorize?` +\n    `expiration=never&` +\n    `name=CliqSync AI&` +\n    `scope=read,write&` +\n    `response_type=token&` +\n    `key=${config.trello.key}&` +\n    `return_url=${encodeURIComponent(redirectUri)}`;\n\n  res.redirect(authUrl);\n};\n\nexports.trelloCallback = async (req, res) => {\n  const { state } = req.query;\n\n  res.send(`\n    <html>\n      <head>\n        <title>Connecting to Trello...</title>\n        <style>\n          body {\n            font-family: Arial, sans-serif;\n            padding: 50px;\n            text-align: center;\n            background: #f5f5f5;\n          }\n          .container {\n            max-width: 500px;\n            margin: 0 auto;\n            background: white;\n            padding: 40px;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n          }\n          .success { color: #27ae60; }\n          .error { color: #e74c3c; }\n          .loading { color: #3498db; }\n        </style>\n      </head>\n      <body>\n        <div class=\"container\">\n          <h1 class=\"loading\" id=\"status\">‚è≥ Processing...</h1>\n          <p id=\"message\">Please wait while we connect your Trello account.</p>\n        </div>\n        <script>\n          (function() {\n            const urlParams = new URLSearchParams(window.location.search);\n            const state = urlParams.get('state');\n            const hash = window.location.hash.substring(1);\n            const hashParams = new URLSearchParams(hash);\n            const token = hashParams.get('token');\n\n            if (!state) {\n              document.getElementById('status').className = 'error';\n              document.getElementById('status').textContent = '‚úó Authentication Failed';\n              document.getElementById('message').textContent = 'Invalid authentication session.';\n              return;\n            }\n\n            if (!token) {\n              document.getElementById('status').className = 'error';\n              document.getElementById('status').textContent = '‚úó Authentication Failed';\n              document.getElementById('message').textContent = 'No token received from Trello.';\n              return;\n            }\n\n            fetch('/auth/trello/complete', {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json'\n              },\n              body: JSON.stringify({ token, state })\n            })\n            .then(response => response.json())\n            .then(data => {\n              if (data.success) {\n                document.getElementById('status').className = 'success';\n                document.getElementById('status').textContent = '‚úì Successfully Connected!';\n                document.getElementById('message').textContent = 'Your Trello account has been linked to CliqSync AI. You can now close this window.';\n              } else {\n                document.getElementById('status').className = 'error';\n                document.getElementById('status').textContent = '‚úó Authentication Failed';\n                document.getElementById('message').textContent = data.error || 'An error occurred.';\n              }\n            })\n            .catch(error => {\n              document.getElementById('status').className = 'error';\n              document.getElementById('status').textContent = '‚úó Error';\n              document.getElementById('message').textContent = 'Failed to complete authentication: ' + error.message;\n            });\n          })();\n        </script>\n      </body>\n    </html>\n  `);\n};\n\nexports.completeAuth = async (req, res) => {\n  try {\n    const { token, state } = req.body;\n\n    if (!token || !state) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Token and state are required' \n      });\n    }\n\n    const sessionData = authSessions.get(state);\n    \n    if (!sessionData) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Invalid or expired authentication session' \n      });\n    }\n\n    const now = Date.now();\n    if (now - sessionData.timestamp > SESSION_TIMEOUT) {\n      authSessions.delete(state);\n      return res.status(400).json({ \n        success: false, \n        error: 'Authentication session expired' \n      });\n    }\n\n    try {\n      const axios = require('axios');\n      const verifyResponse = await axios.get('https://api.trello.com/1/members/me', {\n        params: {\n          key: config.trello.key,\n          token: token,\n          fields: 'id,username'\n        },\n        timeout: 5000\n      });\n\n      if (!verifyResponse.data || !verifyResponse.data.id) {\n        authSessions.delete(state);\n        return res.status(400).json({ \n          success: false, \n          error: 'Invalid Trello token' \n        });\n      }\n\n    } catch (verifyError) {\n      authSessions.delete(state);\n      console.error('Token verification failed:', verifyError.message);\n      return res.status(400).json({ \n        success: false, \n        error: 'Failed to verify Trello token' \n      });\n    }\n\n    authSessions.delete(state);\n    User.upsert(sessionData.userId, token);\n\n    res.json({ \n      success: true, \n      message: 'Authentication successful',\n      userId: sessionData.userId\n    });\n  } catch (error) {\n    console.error('Auth completion error:', error);\n    res.status(500).json({ \n      success: false, \n      error: 'Internal server error' \n    });\n  }\n};","path":null,"size_bytes":6206,"size_tokens":null},"CliqSyncAI/routes/ai.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst aiController = require('../controllers/aiController');\n\nrouter.post('/summarize', aiController.summarizeCard);\nrouter.post('/subtasks', aiController.generateSubtasks);\nrouter.post('/priority', aiController.classifyPriority);\nrouter.post('/chat-to-task', aiController.chatToTask);\n\nmodule.exports = router;\n","path":null,"size_bytes":381,"size_tokens":null},"shared/schema.ts":{"content":"import { pgTable, text, serial, timestamp, integer, boolean } from \"drizzle-orm/pg-core\";\nimport { createInsertSchema } from \"drizzle-zod\";\nimport { z } from \"zod\";\n\nexport const users = pgTable(\"users\", {\n  id: serial(\"id\").primaryKey(),\n  name: text(\"name\").notNull(),\n  email: text(\"email\").notNull().unique(),\n  role: text(\"role\").notNull().default(\"user\"),\n  status: text(\"status\").notNull().default(\"active\"),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n});\n\nexport const insertUserSchema = createInsertSchema(users).omit({\n  id: true,\n  createdAt: true,\n});\n\nexport type InsertUser = z.infer<typeof insertUserSchema>;\nexport type User = typeof users.$inferSelect;\n\nexport const activityLogs = pgTable(\"activity_logs\", {\n  id: serial(\"id\").primaryKey(),\n  userId: integer(\"user_id\").references(() => users.id),\n  action: text(\"action\").notNull(),\n  description: text(\"description\").notNull(),\n  timestamp: timestamp(\"timestamp\").notNull().defaultNow(),\n});\n\nexport const insertActivityLogSchema = createInsertSchema(activityLogs).omit({\n  id: true,\n  timestamp: true,\n});\n\nexport type InsertActivityLog = z.infer<typeof insertActivityLogSchema>;\nexport type ActivityLog = typeof activityLogs.$inferSelect;\n\nexport const analytics = pgTable(\"analytics\", {\n  id: serial(\"id\").primaryKey(),\n  metric: text(\"metric\").notNull(),\n  value: integer(\"value\").notNull(),\n  date: timestamp(\"date\").notNull().defaultNow(),\n});\n\nexport const insertAnalyticsSchema = createInsertSchema(analytics).omit({\n  id: true,\n  date: true,\n});\n\nexport type InsertAnalytics = z.infer<typeof insertAnalyticsSchema>;\nexport type Analytics = typeof analytics.$inferSelect;\n","path":null,"size_bytes":1668,"size_tokens":null},"CliqSyncAI/models/User.js":{"content":"const db = require('../config/database');\n\nclass User {\n  static findByUserId(userId) {\n    const stmt = db.prepare('SELECT * FROM users WHERE userId = ?');\n    return stmt.get(userId);\n  }\n\n  static create(userId, trelloAccessToken, trelloRefreshToken = null, expiresAt = null) {\n    const stmt = db.prepare(`\n      INSERT INTO users (userId, trelloAccessToken, trelloRefreshToken, expiresAt)\n      VALUES (?, ?, ?, ?)\n    `);\n    const result = stmt.run(userId, trelloAccessToken, trelloRefreshToken, expiresAt);\n    return result.lastInsertRowid;\n  }\n\n  static updateToken(userId, trelloAccessToken, trelloRefreshToken = null, expiresAt = null) {\n    const stmt = db.prepare(`\n      UPDATE users \n      SET trelloAccessToken = ?, \n          trelloRefreshToken = ?, \n          expiresAt = ?,\n          updatedAt = strftime('%s', 'now')\n      WHERE userId = ?\n    `);\n    return stmt.run(trelloAccessToken, trelloRefreshToken, expiresAt, userId);\n  }\n\n  static upsert(userId, trelloAccessToken, trelloRefreshToken = null, expiresAt = null) {\n    const existing = this.findByUserId(userId);\n    if (existing) {\n      this.updateToken(userId, trelloAccessToken, trelloRefreshToken, expiresAt);\n    } else {\n      this.create(userId, trelloAccessToken, trelloRefreshToken, expiresAt);\n    }\n  }\n}\n\nmodule.exports = User;\n","path":null,"size_bytes":1319,"size_tokens":null},"CliqSyncAI/README.md":{"content":"# CliqSync AI Backend - Stage 1\n\nAI-Powered Trello Integration Backend for Zoho Cliq\n\n‚ö†Ô∏è **CRITICAL**: This is a Stage 1 backend for **development/testing only**. It requires proper authentication integration before production use. See [SECURITY.md](SECURITY.md) for details.\n\n## üöÄ Features\n\n- **Trello OAuth Authentication** - Secure OAuth flow for connecting Trello accounts\n- **Trello API Integration** - Complete wrapper for Trello operations (boards, lists, cards)\n- **Webhooks** - Real-time event tracking for Trello card changes\n- **AI Integration** - OpenAI-powered features for card summarization, subtask generation, and priority classification\n- **RESTful API** - Clean REST endpoints for all operations\n- **SQLite Database** - Lightweight database for storing tokens and events\n\n## üìÅ Project Structure\n\n```\ncliqsync-ai-backend/\n‚îú‚îÄ‚îÄ config/\n‚îÇ   ‚îú‚îÄ‚îÄ database.js       # Database initialization and schema\n‚îÇ   ‚îî‚îÄ‚îÄ env.js            # Environment configuration\n‚îú‚îÄ‚îÄ controllers/\n‚îÇ   ‚îú‚îÄ‚îÄ authController.js      # Trello OAuth handlers\n‚îÇ   ‚îú‚îÄ‚îÄ trelloController.js    # Trello API handlers\n‚îÇ   ‚îú‚îÄ‚îÄ webhookController.js   # Webhook handlers\n‚îÇ   ‚îî‚îÄ‚îÄ aiController.js        # AI feature handlers\n‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îú‚îÄ‚îÄ User.js           # User model (tokens)\n‚îÇ   ‚îî‚îÄ‚îÄ TrelloEvent.js    # Event model\n‚îú‚îÄ‚îÄ routes/\n‚îÇ   ‚îú‚îÄ‚îÄ auth.js           # Auth routes\n‚îÇ   ‚îú‚îÄ‚îÄ trello.js         # Trello API routes\n‚îÇ   ‚îú‚îÄ‚îÄ webhooks.js       # Webhook routes\n‚îÇ   ‚îú‚îÄ‚îÄ ai.js             # AI routes\n‚îÇ   ‚îî‚îÄ‚îÄ events.js         # Event routes\n‚îú‚îÄ‚îÄ services/\n‚îÇ   ‚îú‚îÄ‚îÄ TrelloService.js  # Trello API wrapper\n‚îÇ   ‚îî‚îÄ‚îÄ AIService.js      # OpenAI integration\n‚îú‚îÄ‚îÄ utils/\n‚îÇ   ‚îî‚îÄ‚îÄ helpers.js        # Utility functions\n‚îú‚îÄ‚îÄ server.js             # Entry point\n‚îú‚îÄ‚îÄ package.json\n‚îú‚îÄ‚îÄ .env.example\n‚îî‚îÄ‚îÄ README.md\n```\n\n## üõ†Ô∏è Installation\n\n1. **Install Dependencies**\n```bash\nnpm install\n```\n\n2. **Configure Environment Variables**\n\nCopy `.env.example` to `.env` and fill in your credentials:\n\n```bash\ncp .env.example .env\n```\n\nRequired variables:\n- `TRELLO_KEY` - Get from https://trello.com/app-key\n- `TRELLO_SECRET` - OAuth secret from Trello\n- `TRELLO_REDIRECT_URI` - Your callback URL (e.g., http://localhost:3000/auth/trello/callback)\n- `OPENAI_API_KEY` - Get from https://platform.openai.com/api-keys\n- `PORT` - Server port (default: 3000)\n\n3. **Start the Server**\n```bash\nnpm start\n```\n\n## üì° API Endpoints\n\n### Health Check\n```\nGET /api/health\n```\n\n### Authentication\n```\nGET  /auth/trello/start?userId=USER_ID\nGET  /auth/trello/callback\n```\n\n### Trello Operations\n```\nGET    /api/trello/boards\nGET    /api/trello/lists?board=BOARD_ID\nGET    /api/trello/cards?list=LIST_ID\nGET    /api/trello/cards/:cardId\nPOST   /api/trello/cards\nPATCH  /api/trello/cards/:cardId\nPOST   /api/trello/cards/:cardId/move\n```\n\n### Webhooks\n```\nPOST   /webhooks/trello\nHEAD   /webhooks/trello\n```\n\n### Events\n```\nGET    /api/events/recent?limit=20\n```\n\n### AI Features\n```\nPOST   /api/ai/summarize\nPOST   /api/ai/subtasks\nPOST   /api/ai/priority\nPOST   /api/ai/chat-to-task\n```\n\n## üîê Authentication Flow\n\n1. Direct user to: `GET /auth/trello/start?userId=YOUR_USER_ID&apiKey=YOUR_API_KEY` \n   - `userId` is required - identifies the user\n   - `apiKey` is required when `JWT_SECRET` is set to a non-default value (can also be sent via `x-api-key` header)\n2. User authorizes on Trello\n3. User is redirected to callback page which extracts token from URL fragment\n4. JavaScript on callback page sends token to server via `POST /auth/trello/complete`\n5. Token is validated against Trello's API to ensure it's genuine\n6. Token is stored in database with state verification\n7. All subsequent API calls use this token\n\n**Important Security Notes:**\n- The `userId` parameter is required for authentication initiation\n- API key protection prevents unauthorized OAuth initiation\n- State parameter is used to prevent CSRF attacks\n- All tokens are verified with Trello before storage\n- Authentication sessions expire after 10 minutes\n- Tokens are securely stored in the database\n- **See [SECURITY.md](SECURITY.md) for production deployment requirements**\n\n## üìù Example API Calls\n\n### Create a Card\n```bash\ncurl -X POST http://localhost:3000/api/trello/cards \\\n  -H \"Content-Type: application/json\" \\\n  -H \"x-user-id: YOUR_USER_ID\" \\\n  -d '{\n    \"listId\": \"LIST_ID\",\n    \"title\": \"New Task\",\n    \"description\": \"Task description\"\n  }'\n```\n\n### Summarize a Card with AI\n```bash\ncurl -X POST http://localhost:3000/api/ai/summarize \\\n  -H \"Content-Type: application/json\" \\\n  -H \"x-user-id: YOUR_USER_ID\" \\\n  -d '{\n    \"cardId\": \"CARD_ID\"\n  }'\n```\n\n### Convert Chat to Task\n```bash\ncurl -X POST http://localhost:3000/api/ai/chat-to-task \\\n  -H \"Content-Type: application/json\" \\\n  -H \"x-user-id: YOUR_USER_ID\" \\\n  -d '{\n    \"text\": \"We need to fix the login bug by tomorrow\",\n    \"listId\": \"LIST_ID\"\n  }'\n```\n\n## üîî Setting Up Trello Webhooks\n\nTo receive real-time events from Trello, you need to create a webhook:\n\n```bash\ncurl -X POST \"https://api.trello.com/1/webhooks/\" \\\n  -d \"key=YOUR_TRELLO_KEY\" \\\n  -d \"token=YOUR_TRELLO_TOKEN\" \\\n  -d \"callbackURL=https://your-domain.com/webhooks/trello\" \\\n  -d \"idModel=YOUR_BOARD_ID\"\n```\n\n## üóÑÔ∏è Database Schema\n\n### Users Table\n- `id` - Auto-increment primary key\n- `userId` - Unique user identifier\n- `trelloAccessToken` - Trello API token\n- `trelloRefreshToken` - Refresh token (if available)\n- `expiresAt` - Token expiration timestamp\n- `createdAt` - Creation timestamp\n- `updatedAt` - Last update timestamp\n\n### Trello Events Table\n- `id` - Auto-increment primary key\n- `eventType` - Type of event (e.g., createCard, updateCard)\n- `cardId` - Card ID\n- `cardName` - Card name\n- `listId` - List ID\n- `listName` - List name\n- `boardId` - Board ID\n- `boardName` - Board name\n- `payload` - Full event payload (JSON)\n- `createdAt` - Event timestamp\n\n## üß™ Testing\n\nTest the health endpoint:\n```bash\ncurl http://localhost:3000/api/health\n```\n\nExpected response:\n```json\n{\n  \"status\": \"OK\",\n  \"service\": \"CliqSync AI Backend\",\n  \"timestamp\": \"2024-01-01T00:00:00.000Z\"\n}\n```\n\n## üîß User Identification\n\nInclude user ID in requests using one of these methods:\n1. Query parameter: `?userId=USER_ID`\n2. Header: `x-user-id: USER_ID`\n\nDefault user ID is `default-user` if not provided.\n\n## üì¶ Dependencies\n\n- **express** - Web framework\n- **dotenv** - Environment variables\n- **axios** - HTTP client\n- **better-sqlite3** - SQLite database\n- **cors** - CORS middleware\n- **body-parser** - Request body parsing\n\n## üöß Stage 1 Scope\n\nThis is Stage 1 backend only. It includes:\n- ‚úÖ Trello OAuth\n- ‚úÖ Trello API wrapper\n- ‚úÖ Webhooks\n- ‚úÖ AI integration\n- ‚úÖ REST API endpoints\n\nNot included in Stage 1:\n- ‚ùå Zoho Cliq extension\n- ‚ùå Zoho Deluge functions\n- ‚ùå Zoho widgets\n- ‚ùå Frontend UI\n\n## üìÑ License\n\nMIT\n","path":null,"size_bytes":7006,"size_tokens":null},"CliqSyncAI/routes/events.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst webhookController = require('../controllers/webhookController');\n\nrouter.get('/recent', webhookController.getRecentEvents);\n\nmodule.exports = router;\n","path":null,"size_bytes":225,"size_tokens":null},"CliqSyncAI/controllers/aiController.js":{"content":"const AIService = require('../services/AIService');\nconst TrelloService = require('../services/TrelloService');\n\nconst getUserId = (req) => {\n  return req.query.userId || req.headers['x-user-id'] || 'default-user';\n};\n\nexports.summarizeCard = async (req, res) => {\n  try {\n    const userId = getUserId(req);\n    const { cardId } = req.body;\n\n    if (!cardId) {\n      return res.status(400).json({ success: false, error: 'cardId is required' });\n    }\n\n    const cardData = await TrelloService.getCardDetails(userId, cardId);\n    const result = await AIService.summarizeCard(cardData);\n\n    res.json({ success: true, data: result });\n  } catch (error) {\n    res.status(500).json({ success: false, error: error.message });\n  }\n};\n\nexports.generateSubtasks = async (req, res) => {\n  try {\n    const userId = getUserId(req);\n    const { cardId } = req.body;\n\n    if (!cardId) {\n      return res.status(400).json({ success: false, error: 'cardId is required' });\n    }\n\n    const cardData = await TrelloService.getCardDetails(userId, cardId);\n    const result = await AIService.generateSubtasks(cardData);\n\n    res.json({ success: true, data: result });\n  } catch (error) {\n    res.status(500).json({ success: false, error: error.message });\n  }\n};\n\nexports.classifyPriority = async (req, res) => {\n  try {\n    const userId = getUserId(req);\n    const { cardId } = req.body;\n\n    if (!cardId) {\n      return res.status(400).json({ success: false, error: 'cardId is required' });\n    }\n\n    const cardData = await TrelloService.getCardDetails(userId, cardId);\n    const result = await AIService.classifyPriority(cardData);\n\n    res.json({ success: true, data: result });\n  } catch (error) {\n    res.status(500).json({ success: false, error: error.message });\n  }\n};\n\nexports.chatToTask = async (req, res) => {\n  try {\n    const userId = getUserId(req);\n    const { text, listId } = req.body;\n\n    if (!text || !listId) {\n      return res.status(400).json({ success: false, error: 'text and listId are required' });\n    }\n\n    const taskData = await AIService.extractTaskFromChat(text);\n    const card = await TrelloService.createCard(userId, listId, taskData.title, taskData.description);\n\n    res.json({ \n      success: true, \n      data: {\n        extractedTask: taskData,\n        createdCard: card\n      }\n    });\n  } catch (error) {\n    res.status(500).json({ success: false, error: error.message });\n  }\n};\n","path":null,"size_bytes":2406,"size_tokens":null},"CliqSyncAI/services/AIService.js":{"content":"const axios = require('axios');\nconst config = require('../config/env');\n\nclass AIService {\n  static async callOpenAI(messages, temperature = 0.7) {\n    if (!config.openai.apiKey) {\n      throw new Error('OpenAI API key not configured');\n    }\n\n    try {\n      const response = await axios.post(\n        'https://api.openai.com/v1/chat/completions',\n        {\n          model: 'gpt-3.5-turbo',\n          messages: messages,\n          temperature: temperature\n        },\n        {\n          headers: {\n            'Authorization': `Bearer ${config.openai.apiKey}`,\n            'Content-Type': 'application/json'\n          }\n        }\n      );\n\n      return response.data.choices[0].message.content;\n    } catch (error) {\n      throw new Error(`OpenAI API Error: ${error.response?.data?.error?.message || error.message}`);\n    }\n  }\n\n  static async summarizeCard(cardData) {\n    const messages = [\n      {\n        role: 'system',\n        content: 'You are a helpful assistant that summarizes Trello cards concisely.'\n      },\n      {\n        role: 'user',\n        content: `Please provide a brief summary of this Trello card:\\n\\nTitle: ${cardData.name}\\nDescription: ${cardData.desc || 'No description'}\\n\\nProvide a concise 2-3 sentence summary.`\n      }\n    ];\n\n    const summary = await this.callOpenAI(messages);\n    return { summary };\n  }\n\n  static async generateSubtasks(cardData) {\n    const messages = [\n      {\n        role: 'system',\n        content: 'You are a helpful assistant that breaks down tasks into actionable subtasks. Return the result as a JSON array of strings.'\n      },\n      {\n        role: 'user',\n        content: `Based on this Trello card, generate 3-5 actionable subtasks:\\n\\nTitle: ${cardData.name}\\nDescription: ${cardData.desc || 'No description'}\\n\\nReturn only a JSON array of subtask strings.`\n      }\n    ];\n\n    const result = await this.callOpenAI(messages, 0.5);\n    \n    try {\n      const subtasks = JSON.parse(result);\n      return { subtasks: Array.isArray(subtasks) ? subtasks : [result] };\n    } catch (e) {\n      const lines = result.split('\\n').filter(line => line.trim());\n      return { subtasks: lines };\n    }\n  }\n\n  static async classifyPriority(cardData) {\n    const messages = [\n      {\n        role: 'system',\n        content: 'You are a helpful assistant that classifies task priority. Respond with only one word: High, Medium, or Low.'\n      },\n      {\n        role: 'user',\n        content: `Classify the priority of this task:\\n\\nTitle: ${cardData.name}\\nDescription: ${cardData.desc || 'No description'}\\n\\nRespond with only: High, Medium, or Low`\n      }\n    ];\n\n    const priority = await this.callOpenAI(messages, 0.3);\n    return { priority: priority.trim() };\n  }\n\n  static async extractTaskFromChat(text) {\n    const messages = [\n      {\n        role: 'system',\n        content: 'You are a helpful assistant that extracts task information from chat messages. Return a JSON object with \"title\" and \"description\" fields.'\n      },\n      {\n        role: 'user',\n        content: `Extract a task title and description from this message:\\n\\n\"${text}\"\\n\\nReturn only a JSON object with \"title\" and \"description\" fields.`\n      }\n    ];\n\n    const result = await this.callOpenAI(messages, 0.5);\n    \n    try {\n      return JSON.parse(result);\n    } catch (e) {\n      return {\n        title: text.substring(0, 100),\n        description: text\n      };\n    }\n  }\n}\n\nmodule.exports = AIService;\n","path":null,"size_bytes":3450,"size_tokens":null},"CliqSyncAI/services/TrelloService.js":{"content":"const axios = require('axios');\nconst User = require('../models/User');\nconst config = require('../config/env');\n\nclass TrelloService {\n  static async getUserToken(userId) {\n    const user = User.findByUserId(userId);\n    if (!user || !user.trelloAccessToken) {\n      throw new Error('User not authenticated with Trello');\n    }\n    return user.trelloAccessToken;\n  }\n\n  static async makeRequest(userId, method, endpoint, data = null) {\n    const token = await this.getUserToken(userId);\n    const url = `https://api.trello.com/1${endpoint}`;\n    \n    const params = {\n      key: config.trello.key,\n      token: token\n    };\n\n    try {\n      const response = await axios({\n        method,\n        url,\n        params,\n        data\n      });\n      return response.data;\n    } catch (error) {\n      throw new Error(`Trello API Error: ${error.response?.data?.message || error.message}`);\n    }\n  }\n\n  static async getBoards(userId) {\n    return await this.makeRequest(userId, 'GET', '/members/me/boards');\n  }\n\n  static async getLists(userId, boardId) {\n    return await this.makeRequest(userId, 'GET', `/boards/${boardId}/lists`);\n  }\n\n  static async getCards(userId, listId) {\n    return await this.makeRequest(userId, 'GET', `/lists/${listId}/cards`);\n  }\n\n  static async getCardDetails(userId, cardId) {\n    return await this.makeRequest(userId, 'GET', `/cards/${cardId}`);\n  }\n\n  static async createCard(userId, listId, title, description = '') {\n    return await this.makeRequest(userId, 'POST', '/cards', {\n      idList: listId,\n      name: title,\n      desc: description\n    });\n  }\n\n  static async updateCard(userId, cardId, updates) {\n    return await this.makeRequest(userId, 'PUT', `/cards/${cardId}`, updates);\n  }\n\n  static async moveCard(userId, cardId, targetListId) {\n    return await this.makeRequest(userId, 'PUT', `/cards/${cardId}`, {\n      idList: targetListId\n    });\n  }\n}\n\nmodule.exports = TrelloService;\n","path":null,"size_bytes":1927,"size_tokens":null},"CliqSyncAI/routes/auth.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst authController = require('../controllers/authController');\n\nrouter.get('/trello/start', authController.startTrelloAuth);\nrouter.get('/trello/callback', authController.trelloCallback);\nrouter.post('/trello/complete', authController.completeAuth);\n\nmodule.exports = router;\n","path":null,"size_bytes":347,"size_tokens":null},"CliqSyncAI/utils/helpers.js":{"content":"const crypto = require('crypto');\n\nfunction generateRandomString(length = 16) {\n  return crypto.randomBytes(length).toString('hex');\n}\n\nfunction validateEmail(email) {\n  const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return re.test(email);\n}\n\nfunction formatDate(timestamp) {\n  return new Date(timestamp * 1000).toISOString();\n}\n\nmodule.exports = {\n  generateRandomString,\n  validateEmail,\n  formatDate\n};\n","path":null,"size_bytes":402,"size_tokens":null},"server/storage.ts":{"content":"import { drizzle } from \"drizzle-orm/neon-serverless\";\nimport { Pool, neonConfig } from \"@neondatabase/serverless\";\nimport ws from \"ws\";\nimport {\n  users,\n  activityLogs,\n  analytics,\n  InsertUser,\n  User,\n  InsertActivityLog,\n  ActivityLog,\n  InsertAnalytics,\n  Analytics,\n} from \"@shared/schema\";\nimport { eq, desc, sql } from \"drizzle-orm\";\n\nneonConfig.webSocketConstructor = ws;\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\"DATABASE_URL must be set\");\n}\n\nconst pool = new Pool({ connectionString: process.env.DATABASE_URL });\nconst db = drizzle({ client: pool });\n\nexport interface IStorage {\n  getUsers(): Promise<User[]>;\n  getUserById(id: number): Promise<User | undefined>;\n  createUser(user: InsertUser): Promise<User>;\n  updateUser(id: number, user: Partial<InsertUser>): Promise<User | undefined>;\n  deleteUser(id: number): Promise<boolean>;\n  \n  getActivityLogs(limit?: number): Promise<ActivityLog[]>;\n  createActivityLog(log: InsertActivityLog): Promise<ActivityLog>;\n  \n  getAnalytics(): Promise<Analytics[]>;\n  createAnalytics(data: InsertAnalytics): Promise<Analytics>;\n  getDashboardStats(): Promise<{\n    totalUsers: number;\n    activeUsers: number;\n    totalActivity: number;\n    growthRate: number;\n  }>;\n}\n\nclass Storage implements IStorage {\n  async getUsers(): Promise<User[]> {\n    return await db.select().from(users).orderBy(desc(users.createdAt));\n  }\n\n  async getUserById(id: number): Promise<User | undefined> {\n    const [user] = await db.select().from(users).where(eq(users.id, id));\n    return user;\n  }\n\n  async createUser(user: InsertUser): Promise<User> {\n    const [newUser] = await db.insert(users).values(user).returning();\n    return newUser;\n  }\n\n  async updateUser(id: number, user: Partial<InsertUser>): Promise<User | undefined> {\n    const [updatedUser] = await db\n      .update(users)\n      .set(user)\n      .where(eq(users.id, id))\n      .returning();\n    return updatedUser;\n  }\n\n  async deleteUser(id: number): Promise<boolean> {\n    const result = await db.delete(users).where(eq(users.id, id));\n    return result.rowCount !== null && result.rowCount > 0;\n  }\n\n  async getActivityLogs(limit: number = 10): Promise<ActivityLog[]> {\n    return await db\n      .select()\n      .from(activityLogs)\n      .orderBy(desc(activityLogs.timestamp))\n      .limit(limit);\n  }\n\n  async createActivityLog(log: InsertActivityLog): Promise<ActivityLog> {\n    const [newLog] = await db.insert(activityLogs).values(log).returning();\n    return newLog;\n  }\n\n  async getAnalytics(): Promise<Analytics[]> {\n    return await db.select().from(analytics).orderBy(desc(analytics.date));\n  }\n\n  async createAnalytics(data: InsertAnalytics): Promise<Analytics> {\n    const [newData] = await db.insert(analytics).values(data).returning();\n    return newData;\n  }\n\n  async getDashboardStats() {\n    const totalUsersResult = await db\n      .select({ count: sql<number>`count(*)::int` })\n      .from(users);\n    \n    const activeUsersResult = await db\n      .select({ count: sql<number>`count(*)::int` })\n      .from(users)\n      .where(eq(users.status, \"active\"));\n    \n    const totalActivityResult = await db\n      .select({ count: sql<number>`count(*)::int` })\n      .from(activityLogs);\n\n    return {\n      totalUsers: totalUsersResult[0]?.count || 0,\n      activeUsers: activeUsersResult[0]?.count || 0,\n      totalActivity: totalActivityResult[0]?.count || 0,\n      growthRate: 12.5,\n    };\n  }\n}\n\nexport const storage = new Storage();\n","path":null,"size_bytes":3469,"size_tokens":null},"CliqSyncAI/routes/webhooks.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst webhookController = require('../controllers/webhookController');\n\nrouter.post('/trello', webhookController.handleTrelloWebhook);\nrouter.head('/trello', webhookController.handleTrelloWebhook);\n\nmodule.exports = router;\n","path":null,"size_bytes":293,"size_tokens":null},"CliqSyncAI/routes/trello.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst trelloController = require('../controllers/trelloController');\n\nrouter.get('/boards', trelloController.getBoards);\nrouter.get('/lists', trelloController.getLists);\nrouter.get('/cards', trelloController.getCards);\nrouter.get('/cards/:cardId', trelloController.getCardDetails);\nrouter.post('/cards', trelloController.createCard);\nrouter.patch('/cards/:cardId', trelloController.updateCard);\nrouter.post('/cards/:cardId/move', trelloController.moveCard);\n\nmodule.exports = router;\n","path":null,"size_bytes":553,"size_tokens":null},"CliqSyncAI/replit.md":{"content":"# CliqSync AI Backend - Project Information\n\n## Project Overview\nThis is the **Stage-1 backend** for CliqSync AI, an AI-Powered Trello Integration for Zoho Cliq.\n\n**Current Status**: Stage 1 Complete - Backend API and services built\n\n**Important**: This is a development backend built in isolation. It requires integration with Zoho Cliq authentication (Stage 2+) before production deployment.\n\n## Architecture\n\n### Technology Stack\n- **Runtime**: Node.js 20\n- **Framework**: Express.js\n- **Database**: SQLite (better-sqlite3)\n- **HTTP Client**: Axios\n- **AI**: OpenAI GPT-3.5-turbo\n\n### Project Structure\n```\n‚îú‚îÄ‚îÄ config/          - Database and environment configuration\n‚îú‚îÄ‚îÄ controllers/     - Request handlers for all routes\n‚îú‚îÄ‚îÄ models/          - Database models (User, TrelloEvent)\n‚îú‚îÄ‚îÄ routes/          - API route definitions\n‚îú‚îÄ‚îÄ services/        - Business logic (Trello API, AI)\n‚îú‚îÄ‚îÄ utils/           - Helper functions\n‚îî‚îÄ‚îÄ server.js        - Application entry point\n```\n\n### Key Features Implemented\n1. ‚úÖ Trello OAuth 2.0 flow with token verification\n2. ‚úÖ Complete Trello API wrapper (boards, lists, cards)\n3. ‚úÖ Webhook endpoint for real-time Trello events\n4. ‚úÖ OpenAI integration for AI features\n5. ‚úÖ REST API for all operations\n6. ‚úÖ SQLite database for token and event storage\n\n## API Endpoints\n\n### Authentication\n- `GET /auth/trello/start` - Initiate OAuth (requires userId and apiKey)\n- `GET /auth/trello/callback` - OAuth callback handler\n- `POST /auth/trello/complete` - Complete OAuth with token verification\n\n### Trello Operations\n- `GET /api/trello/boards` - Get user's Trello boards\n- `GET /api/trello/lists?board=ID` - Get lists for a board\n- `GET /api/trello/cards?list=ID` - Get cards for a list\n- `GET /api/trello/cards/:cardId` - Get card details\n- `POST /api/trello/cards` - Create a new card\n- `PATCH /api/trello/cards/:cardId` - Update a card\n- `POST /api/trello/cards/:cardId/move` - Move card to different list\n\n### AI Features\n- `POST /api/ai/summarize` - AI-powered card summarization\n- `POST /api/ai/subtasks` - Generate subtasks from card\n- `POST /api/ai/priority` - Classify card priority\n- `POST /api/ai/chat-to-task` - Extract task from chat message\n\n### Webhooks & Events\n- `POST /webhooks/trello` - Receive Trello webhook events\n- `GET /api/events/recent` - Get recent Trello events\n\n### Health Check\n- `GET /api/health` - Service health status\n\n## Environment Variables\n\nRequired:\n- `TRELLO_KEY` - Trello API key\n- `TRELLO_SECRET` - Trello OAuth secret (currently unused in implicit flow)\n- `TRELLO_REDIRECT_URI` - OAuth callback URL\n- `OPENAI_API_KEY` - OpenAI API key\n\nOptional:\n- `PORT` - Server port (default: 3000)\n- `DB_PATH` - SQLite database path (default: ./database.sqlite)\n- `JWT_SECRET` - API key for OAuth initiation (development only)\n\n## Database Schema\n\n### users table\n- Stores Trello OAuth tokens per userId\n- Fields: userId, trelloAccessToken, trelloRefreshToken, expiresAt\n\n### trello_events table\n- Stores webhook events from Trello\n- Fields: eventType, cardId, cardName, listId, boardId, payload, createdAt\n\n## Security Considerations\n\n**IMPORTANT**: See SECURITY.md for critical security limitations and production requirements.\n\nKey points:\n- Current OAuth implementation uses shared API key (not production-ready)\n- Requires integration with proper session-based authentication\n- All Trello tokens are verified before storage\n- State parameter prevents CSRF attacks\n- Sessions expire after 10 minutes\n\n## Development Workflow\n\n1. Server runs on port 3000\n2. Health check: `curl http://localhost:3000/api/health`\n3. Workflow: \"Start Backend Server\" - runs `node server.js`\n\n## Next Steps (Stage 2+)\n\n1. Build Zoho Cliq extension\n2. Integrate proper user authentication\n3. Replace API key with session-based auth\n4. Implement webhook verification\n5. Add rate limiting and production hardening\n6. Deploy to production environment\n\n## Recent Changes\n\n- 2024-11-25: Initial Stage-1 backend implementation complete\n  - OAuth flow with token verification\n  - Trello API service layer\n  - AI integration with OpenAI\n  - Webhook event handling\n  - Comprehensive documentation and security notes\n\n## User Preferences\n\nNone specified yet.\n","path":null,"size_bytes":4245,"size_tokens":null},"CliqSyncAI/models/TrelloEvent.js":{"content":"const db = require('../config/database');\n\nclass TrelloEvent {\n  static create(eventData) {\n    const stmt = db.prepare(`\n      INSERT INTO trello_events (eventType, cardId, cardName, listId, listName, boardId, boardName, payload)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n    const result = stmt.run(\n      eventData.eventType,\n      eventData.cardId,\n      eventData.cardName,\n      eventData.listId,\n      eventData.listName,\n      eventData.boardId,\n      eventData.boardName,\n      JSON.stringify(eventData.payload)\n    );\n    return result.lastInsertRowid;\n  }\n\n  static getRecent(limit = 20) {\n    const stmt = db.prepare(`\n      SELECT * FROM trello_events \n      ORDER BY createdAt DESC \n      LIMIT ?\n    `);\n    const events = stmt.all(limit);\n    return events.map(event => ({\n      ...event,\n      payload: JSON.parse(event.payload)\n    }));\n  }\n\n  static getAll() {\n    const stmt = db.prepare('SELECT * FROM trello_events ORDER BY createdAt DESC');\n    const events = stmt.all();\n    return events.map(event => ({\n      ...event,\n      payload: JSON.parse(event.payload)\n    }));\n  }\n}\n\nmodule.exports = TrelloEvent;\n","path":null,"size_bytes":1136,"size_tokens":null},"CliqSyncAI/config/env.js":{"content":"require('dotenv').config();\n\nmodule.exports = {\n  port: process.env.PORT || 5000,\n  trello: {\n    key: process.env.TRELLO_KEY,\n    secret: process.env.TRELLO_SECRET,\n    redirectUri: process.env.TRELLO_REDIRECT_URI\n  },\n  openai: {\n    apiKey: process.env.OPENAI_API_KEY\n  },\n  db: {\n    path: process.env.DB_PATH || './database.sqlite'\n  },\n  jwt: {\n    secret: process.env.JWT_SECRET || 'default-secret-change-in-production'\n  }\n};\n","path":null,"size_bytes":434,"size_tokens":null},"server/routes.ts":{"content":"import type { Express } from \"express\";\nimport { storage } from \"./storage\";\nimport { insertUserSchema, insertActivityLogSchema, insertAnalyticsSchema } from \"@shared/schema\";\nimport { z } from \"zod\";\nimport { fromZodError } from \"zod-validation-error\";\n\nexport function registerRoutes(app: Express) {\n  app.get(\"/api/users\", async (req, res) => {\n    try {\n      const users = await storage.getUsers();\n      res.json(users);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to fetch users\" });\n    }\n  });\n\n  app.get(\"/api/users/:id\", async (req, res) => {\n    try {\n      const id = parseInt(req.params.id);\n      const user = await storage.getUserById(id);\n      if (!user) {\n        return res.status(404).json({ error: \"User not found\" });\n      }\n      res.json(user);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to fetch user\" });\n    }\n  });\n\n  app.post(\"/api/users\", async (req, res) => {\n    try {\n      const result = insertUserSchema.safeParse(req.body);\n      if (!result.success) {\n        return res.status(400).json({ error: fromZodError(result.error).message });\n      }\n      const user = await storage.createUser(result.data);\n      await storage.createActivityLog({\n        userId: user.id,\n        action: \"user_created\",\n        description: `User ${user.name} was created`,\n      });\n      res.status(201).json(user);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to create user\" });\n    }\n  });\n\n  app.patch(\"/api/users/:id\", async (req, res) => {\n    try {\n      const id = parseInt(req.params.id);\n      const result = insertUserSchema.partial().safeParse(req.body);\n      if (!result.success) {\n        return res.status(400).json({ error: fromZodError(result.error).message });\n      }\n      const user = await storage.updateUser(id, result.data);\n      if (!user) {\n        return res.status(404).json({ error: \"User not found\" });\n      }\n      await storage.createActivityLog({\n        userId: user.id,\n        action: \"user_updated\",\n        description: `User ${user.name} was updated`,\n      });\n      res.json(user);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to update user\" });\n    }\n  });\n\n  app.delete(\"/api/users/:id\", async (req, res) => {\n    try {\n      const id = parseInt(req.params.id);\n      const user = await storage.getUserById(id);\n      if (!user) {\n        return res.status(404).json({ error: \"User not found\" });\n      }\n      const deleted = await storage.deleteUser(id);\n      if (deleted) {\n        await storage.createActivityLog({\n          userId: null,\n          action: \"user_deleted\",\n          description: `User ${user.name} was deleted`,\n        });\n        res.status(204).send();\n      } else {\n        res.status(404).json({ error: \"User not found\" });\n      }\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to delete user\" });\n    }\n  });\n\n  app.get(\"/api/activity-logs\", async (req, res) => {\n    try {\n      const limit = req.query.limit ? parseInt(req.query.limit as string) : 10;\n      const logs = await storage.getActivityLogs(limit);\n      res.json(logs);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to fetch activity logs\" });\n    }\n  });\n\n  app.post(\"/api/activity-logs\", async (req, res) => {\n    try {\n      const result = insertActivityLogSchema.safeParse(req.body);\n      if (!result.success) {\n        return res.status(400).json({ error: fromZodError(result.error).message });\n      }\n      const log = await storage.createActivityLog(result.data);\n      res.status(201).json(log);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to create activity log\" });\n    }\n  });\n\n  app.get(\"/api/analytics\", async (req, res) => {\n    try {\n      const analytics = await storage.getAnalytics();\n      res.json(analytics);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to fetch analytics\" });\n    }\n  });\n\n  app.post(\"/api/analytics\", async (req, res) => {\n    try {\n      const result = insertAnalyticsSchema.safeParse(req.body);\n      if (!result.success) {\n        return res.status(400).json({ error: fromZodError(result.error).message });\n      }\n      const data = await storage.createAnalytics(result.data);\n      res.status(201).json(data);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to create analytics data\" });\n    }\n  });\n\n  app.get(\"/api/dashboard/stats\", async (req, res) => {\n    try {\n      const stats = await storage.getDashboardStats();\n      res.json(stats);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to fetch dashboard stats\" });\n    }\n  });\n}\n","path":null,"size_bytes":4649,"size_tokens":null},"CliqSyncAI/controllers/trelloController.js":{"content":"const TrelloService = require('../services/TrelloService');\n\nconst getUserId = (req) => {\n  return req.query.userId || req.headers['x-user-id'] || 'default-user';\n};\n\nexports.getBoards = async (req, res) => {\n  try {\n    const userId = getUserId(req);\n    const boards = await TrelloService.getBoards(userId);\n    res.json({ success: true, data: boards });\n  } catch (error) {\n    res.status(500).json({ success: false, error: error.message });\n  }\n};\n\nexports.getLists = async (req, res) => {\n  try {\n    const userId = getUserId(req);\n    const { board } = req.query;\n\n    if (!board) {\n      return res.status(400).json({ success: false, error: 'board parameter is required' });\n    }\n\n    const lists = await TrelloService.getLists(userId, board);\n    res.json({ success: true, data: lists });\n  } catch (error) {\n    res.status(500).json({ success: false, error: error.message });\n  }\n};\n\nexports.getCards = async (req, res) => {\n  try {\n    const userId = getUserId(req);\n    const { list } = req.query;\n\n    if (!list) {\n      return res.status(400).json({ success: false, error: 'list parameter is required' });\n    }\n\n    const cards = await TrelloService.getCards(userId, list);\n    res.json({ success: true, data: cards });\n  } catch (error) {\n    res.status(500).json({ success: false, error: error.message });\n  }\n};\n\nexports.getCardDetails = async (req, res) => {\n  try {\n    const userId = getUserId(req);\n    const { cardId } = req.params;\n\n    const card = await TrelloService.getCardDetails(userId, cardId);\n    res.json({ success: true, data: card });\n  } catch (error) {\n    res.status(500).json({ success: false, error: error.message });\n  }\n};\n\nexports.createCard = async (req, res) => {\n  try {\n    const userId = getUserId(req);\n    const { listId, title, description } = req.body;\n\n    if (!listId || !title) {\n      return res.status(400).json({ success: false, error: 'listId and title are required' });\n    }\n\n    const card = await TrelloService.createCard(userId, listId, title, description);\n    res.json({ success: true, data: card });\n  } catch (error) {\n    res.status(500).json({ success: false, error: error.message });\n  }\n};\n\nexports.updateCard = async (req, res) => {\n  try {\n    const userId = getUserId(req);\n    const { cardId } = req.params;\n    const updates = req.body;\n\n    const card = await TrelloService.updateCard(userId, cardId, updates);\n    res.json({ success: true, data: card });\n  } catch (error) {\n    res.status(500).json({ success: false, error: error.message });\n  }\n};\n\nexports.moveCard = async (req, res) => {\n  try {\n    const userId = getUserId(req);\n    const { cardId } = req.params;\n    const { targetListId } = req.body;\n\n    if (!targetListId) {\n      return res.status(400).json({ success: false, error: 'targetListId is required' });\n    }\n\n    const card = await TrelloService.moveCard(userId, cardId, targetListId);\n    res.json({ success: true, data: card });\n  } catch (error) {\n    res.status(500).json({ success: false, error: error.message });\n  }\n};\n","path":null,"size_bytes":3029,"size_tokens":null},"CliqSyncAI/SECURITY.md":{"content":"# Security Considerations for CliqSync AI Backend\n\n## ‚ö†Ô∏è CRITICAL WARNING - Stage 1 Implementation Status\n\n**THIS BACKEND IS NOT PRODUCTION-READY AS-IS**\n\nThis is a **Stage 1 backend** built in isolation for development and testing purposes only. It requires proper authentication integration (Stage 2+) before production deployment.\n\n### Known Security Limitations\n\nüî¥ **CRITICAL**: The OAuth flow currently has the following limitation:\n- The `/auth/trello/start` endpoint uses a shared API key instead of per-user session authentication\n- This means anyone with the API key can initiate OAuth for any userId\n- While tokens are verified with Trello before storage, this does not prevent token substitution attacks\n- **Do NOT use this in production without implementing proper session-based authentication**\n\n### Current Security Measures (Insufficient for Production)\n\nThe following measures are implemented but do NOT make this production-ready:\n\n1. **State Parameter CSRF Protection**: Cryptographically secure state parameter\n2. **Session Timeout**: Authentication sessions expire after 10 minutes  \n3. **Token Verification**: All Trello tokens are verified against Trello's API before storage\n4. **API Key Protection**: Shared API key requirement (weak - not per-user authentication)\n\n### Why This Approach for Stage 1?\n\nThis backend is designed to be integrated with a Zoho Cliq extension (Stage 2+) that will provide:\n- Per-user authentication\n- Authenticated user sessions\n- Secure userId binding\n\nStage 1 focuses on building the core backend functionality (Trello API, webhooks, AI) in isolation before integration.\n\n## Production Integration Requirements\n\nWhen integrating this backend with the Zoho Cliq extension (Stage 2+), the following changes **MUST** be implemented:\n\n### 1. Authenticated Sessions\n\nReplace the API key mechanism with proper authenticated sessions:\n\n```javascript\n// Instead of passing userId as a query parameter:\nGET /auth/trello/start?userId=USER_123&apiKey=SECRET\n\n// Use authenticated session middleware:\napp.use(session({\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: false,\n  cookie: { secure: true, httpOnly: true }\n}));\n\n// Extract userId from authenticated session:\nexports.startTrelloAuth = (req, res) => {\n  const userId = req.session.userId; // From authenticated session\n  // ... rest of OAuth flow\n};\n```\n\n### 2. Session Binding\n\nEnsure the OAuth callback validates that the user completing the flow is the same user who initiated it:\n\n```javascript\n// Store session ID with state:\nauthSessions.set(state, { \n  userId, \n  sessionId: req.sessionID,\n  timestamp: Date.now() \n});\n\n// Validate session ID in callback:\nif (sessionData.sessionId !== req.sessionID) {\n  return res.status(403).json({ error: 'Session mismatch' });\n}\n```\n\n### 3. Additional Security Measures\n\n#### For Production Deployment:\n\n1. **HTTPS Only**: \n   - Enable `secure: true` for all cookies\n   - Use HTTPS for all endpoints\n   - Update `TRELLO_REDIRECT_URI` to use HTTPS\n\n2. **Rate Limiting**:\n   ```javascript\n   const rateLimit = require('express-rate-limit');\n   \n   const authLimiter = rateLimit({\n     windowMs: 15 * 60 * 1000, // 15 minutes\n     max: 5 // limit each IP to 5 requests per windowMs\n   });\n   \n   app.use('/auth/', authLimiter);\n   ```\n\n3. **CORS Configuration**:\n   ```javascript\n   app.use(cors({\n     origin: process.env.ALLOWED_ORIGINS.split(','),\n     credentials: true\n   }));\n   ```\n\n4. **Input Validation**:\n   - Validate all user inputs\n   - Sanitize data before database operations\n   - Use parameterized queries (already implemented)\n\n5. **Secure Headers**:\n   ```javascript\n   const helmet = require('helmet');\n   app.use(helmet());\n   ```\n\n6. **Token Rotation**:\n   - Implement token refresh mechanism\n   - Rotate tokens periodically\n   - Revoke tokens on logout\n\n7. **Audit Logging**:\n   - Log all authentication attempts\n   - Log all API calls with timestamps\n   - Monitor for suspicious activity\n\n## Environment Variables Security\n\n**Never commit `.env` files to version control**\n\nRequired environment variables for production:\n\n```bash\n# Strong, unique secrets\nJWT_SECRET=<strong-random-secret-256-bits>\nSESSION_SECRET=<different-strong-random-secret>\n\n# Trello credentials (keep secret)\nTRELLO_KEY=<from-trello-app-key>\nTRELLO_SECRET=<from-trello>\nTRELLO_REDIRECT_URI=https://your-domain.com/auth/trello/callback\n\n# OpenAI (keep secret)\nOPENAI_API_KEY=<from-openai>\n\n# Database (use encrypted connection in production)\nDB_PATH=/secure/path/to/database.sqlite\n\n# Production settings\nNODE_ENV=production\nPORT=3000\n```\n\n## Zoho Cliq Integration (Stage 2+)\n\nWhen integrating with Zoho Cliq:\n\n1. Use Zoho's authentication mechanism to identify users\n2. Pass authenticated user context to backend API calls\n3. Implement webhook verification for Zoho Cliq events\n4. Use Zoho's secret management for API keys\n\n## Reporting Security Issues\n\nIf you discover a security vulnerability, please email security@yourcompany.com instead of using the issue tracker.\n\n## Security Checklist for Production\n\n- [ ] Replace API key auth with proper session-based authentication\n- [ ] Implement session binding for OAuth flow\n- [ ] Enable HTTPS everywhere\n- [ ] Add rate limiting to all endpoints\n- [ ] Configure CORS with specific allowed origins\n- [ ] Add security headers (helmet.js)\n- [ ] Implement audit logging\n- [ ] Set up token rotation\n- [ ] Review and update all secrets\n- [ ] Enable database encryption at rest\n- [ ] Set up monitoring and alerting\n- [ ] Perform security audit/penetration testing\n- [ ] Review and test error handling (no sensitive data in errors)\n- [ ] Implement proper backup and disaster recovery\n","path":null,"size_bytes":5699,"size_tokens":null}},"version":2}